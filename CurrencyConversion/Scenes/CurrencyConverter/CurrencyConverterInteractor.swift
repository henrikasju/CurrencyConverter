//
//  CurrencyConverterInteractor.swift
//  CurrencyConversion
//
//  Created by Henrikas J on 09/01/2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Alamofire
import RealmSwift

protocol CurrencyConverterBusinessLogic
{
  func fetchCurrencyConversion(request: CurrencyConverter.FetchCurrencyConversion.Request)
  func fetchCollectionViewModels(request: CurrencyConverter.CollectionView.Request)
  func fetchCurrencyConversionContract(request: CurrencyConverter.FetchCurrencyConversionContract.Request)
  func completeCurrencyConversionContract(request: CurrencyConverter.CompleteCurrencyConversionContract.Request)
  func fetchAvailableCurrencies(request: CurrencyConverter.FetchAvailableCurrencies.Request)
}

protocol CurrencyConverterDataStore
{
}

class CurrencyConverterInteractor: CurrencyConverterBusinessLogic, CurrencyConverterDataStore {
  var presenter: CurrencyConverterPresentationLogic!
//  var worker: CurrencyConversionWorker?
  var currencyConversionWorker: CurrencyConversionWorker!
  var databaseWorker: DatabaseWorker!
  // Should be using current locale, and format every data to users locale at presenter.
  var numberFormatter: NumberFormatter = {
    let formater = NumberFormatter()
    formater.locale = Locale(identifier: "en_US")
    formater.numberStyle = .decimal

    return formater
  }()

  init(presenter: CurrencyConverterPresentationLogic, currencyConversionWorker: CurrencyConversionWorker, databaseWorker: DatabaseWorker) {
    self.presenter = presenter
    self.currencyConversionWorker = currencyConversionWorker
    self.databaseWorker = databaseWorker
  }

  func fetchCurrencyConversion(request: CurrencyConverter.FetchCurrencyConversion.Request)
  {
    let inputValue = convertStringToDouble(value: request.fromAmount)
    if inputValue == nil || inputValue! < 0 {
      let response = CurrencyConverter.FetchCurrencyConversion.Response(error: ErrorType.InvalidConversionInput())
      presenter?.presentCurrencyConversion(response: response)
    }

      currencyConversionWorker?.fetchConvertedCurrency(fromAmount: request.fromAmount,
                                                       fromCurrency: request.fromCurrency,
                                                       toCurrency: request.toCurrency,
                                                       completion:
      { response in
        switch response.result {
        case .success:
          let conversion: CurrencyConverter.FetchCurrencyConversion.Response
          if let toCell = request.toCell {
              conversion = CurrencyConverter.FetchCurrencyConversion.Response(
              fromConversion: ConvertedCurrency(amount: request.fromAmount, currency: request.fromCurrency),
              toConversion: response.value,
              toCell: toCell)
          }else {
            conversion = CurrencyConverter.FetchCurrencyConversion.Response(toConversion: response.value)
          }
          self.presenter?.presentCurrencyConversion(response: conversion)
        case let .failure(error):
          let conversion = CurrencyConverter.FetchCurrencyConversion.Response(error: error)
          self.presenter?.presentCurrencyConversion(response: conversion)
        }
      })
  }

  private func convertStringToDouble(value: String) -> Double? {
    return numberFormatter.number(from: value)?.doubleValue
  }

  private func validateConversionInputValue(inputValue: String) -> Bool {
    let value: Double? = convertStringToDouble(value: inputValue)
    return (value == nil ? false : (value! <= 0 ? false : true) )
  }

  func fetchCollectionViewModels(request: CurrencyConverter.CollectionView.Request) {

    switch request.type {
    case .Balance:
      var response: CurrencyConverter.CollectionView.Response.BalanceCell

      let storedCurrency = databaseWorker?.getAllStoredCurrencies()
      if let objects = storedCurrency {
        response = CurrencyConverter.CollectionView.Response.BalanceCell(objects: objects)
      }else{
        response = CurrencyConverter.CollectionView.Response.BalanceCell(error: ErrorType.DatabaseRequestedObjectNotExisting())
      }

      presenter?.presentBalanceCells(response: response)
    default:
      break
    }
  }

  func fetchCurrencyConversionContract(request: CurrencyConverter.FetchCurrencyConversionContract.Request) {

    if !validateConversionInputValue(inputValue: request.fromAmount) {
      let response = CurrencyConverter.FetchCurrencyConversionContract.Response(error: ErrorType.InvalidConversionInput())
      presenter?.presentCurrencyConversionContract(response: response)
    }

      currencyConversionWorker?.fetchConvertedCurrency(fromAmount: request.fromAmount,
                                                       fromCurrency: request.fromCurrency,
                                                       toCurrency: request.toCurrency,
                                                       completion:
      { response in
        switch response.result {
        case .success:
          // Calculating fee
          let inputAmount = self.numberFormatter.number(from: request.fromAmount)!.doubleValue
          let taxVisitor: TaxVisitor = FlatRateTaxVisitor()
          let conversionTax = self.calculateConversionFee(visitor: taxVisitor)
          let feeRate = conversionTax.rate
          let fee = inputAmount * feeRate

          // Gathering stored converting currency
          let fromStoredCurrency = self.databaseWorker?.getStoredCurrency(name: request.fromCurrency)

          if let fromCurrentCurrency = fromStoredCurrency {
            // Calculating required total amount for conversion
            let requiredTotalAmount = inputAmount * (1 + feeRate)
            let validConversion = requiredTotalAmount <= fromCurrentCurrency.holdingAmount

            if !validConversion {
              // Error invalid request, funds are not sufficient
              let error = ErrorType.InsufficientConvertingFunds(message: String(format: "Converting amount: %@ %@ to %@ %@, requires additional %.2f %@ as fee. Total required amount: %.2f %@",
                                                                                request.fromAmount, request.fromCurrency, response.value!.amount,
                                                                                response.value!.currency, fee, request.fromCurrency, requiredTotalAmount, request.fromCurrency ))
              let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: error)
              self.presenter?.presentCompleteCurrencyConversionContract(response: response)
            }else {
              let response = CurrencyConverter.FetchCurrencyConversionContract.Response(fromAmount: request.fromAmount ,totalAmount: requiredTotalAmount, fromCurrency: request.fromCurrency, toCurrency: request.toCurrency, toAmount: response.value!.amount, feeRate: feeRate*100, fee: fee)
              self.presenter?.presentCurrencyConversionContract(response: response)
            }
            
          }else{
            // Unable to receive currency from DB
            let response = CurrencyConverter.FetchCurrencyConversionContract.Response(error: ErrorType.UnsuportedCurrencyRequest())
            self.presenter?.presentCurrencyConversionContract(response: response)
          }

        case let .failure(error):
          let response = CurrencyConverter.FetchCurrencyConversionContract.Response(error: error)
          self.presenter?.presentCurrencyConversionContract(response: response)
        }
      })
  }

  func completeCurrencyConversionContract(request: CurrencyConverter.CompleteCurrencyConversionContract.Request) {
    if !validateConversionInputValue(inputValue: request.fromAmount) {
      let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: ErrorType.InvalidConversionInput())
      presenter?.presentCompleteCurrencyConversionContract(response: response)
    }

      currencyConversionWorker?.fetchConvertedCurrency(fromAmount: request.fromAmount,
                                                       fromCurrency: request.fromCurrency,
                                                       toCurrency: request.toCurrency,
                                                       completion:
      { response in
        switch response.result {
        case .success:
          // Calculating fee
          let inputAmount = self.numberFormatter.number(from: request.fromAmount)!.doubleValue
          let outputAmount = self.numberFormatter.number(from: response.value!.amount)!.doubleValue
          let taxVisitor: TaxVisitor = FlatRateTaxVisitor()
          let conversionTax = self.calculateConversionFee(visitor: taxVisitor)
          let feeRate = conversionTax.rate
          let fee = inputAmount * feeRate

          // Gathering stored converting currency
          let fromStoredCurrency = self.databaseWorker?.getStoredCurrency(name: request.fromCurrency)
          let toStoredCurrency = self.databaseWorker?.getStoredCurrency(name: response.value!.currency)

          if let fromCurrentCurrency = fromStoredCurrency, let toCurrentCurrency = toStoredCurrency {
            // Calculating required total amount for conversion
            let requiredTotalAmount = inputAmount * (1 + feeRate)
            let validConversion = requiredTotalAmount <= fromCurrentCurrency.holdingAmount

            if !validConversion {
              // Error invalid request, funds are not sufficient
              let error = ErrorType.InsufficientConvertingFunds(message: String(format: "Converting amount: %@ %@ to %@ %@, requires additional %.2f %@ as fee. Total required amount: %.2f %@",
                                                                                request.fromAmount, request.fromCurrency, response.value!.amount,
                                                                                response.value!.currency, fee, request.fromCurrency, requiredTotalAmount, request.fromCurrency ))
              let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: error)
              self.presenter?.presentCompleteCurrencyConversionContract(response: response)
            }else{
              let transaction: ConvertedCurrencyTransaction = {
                let transaction = ConvertedCurrencyTransaction()
                transaction.fromCurrency = request.fromCurrency
                transaction.fromAmount.value = inputAmount
                transaction.fromTotalAmount.value = requiredTotalAmount
                transaction.feeRate.value = feeRate
                transaction.feeAmount.value = fee
                transaction.toCurrency = response.value!.currency
                transaction.toAmount.value = outputAmount

                return transaction
              }()

              // Saving transaction
              self.databaseWorker?.addConvertedCurrencyTransaction(objects: [transaction]) { error in
                let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: error)
                self.presenter?.presentCompleteCurrencyConversionContract(response: response)
              }

              // Converting funds
              let updatedFromCurrentCurrency: StoredCurrency = {
                let storedCurrency = StoredCurrency()
                storedCurrency.name = fromCurrentCurrency.name
                storedCurrency.holdingAmount = fromCurrentCurrency.holdingAmount - requiredTotalAmount

                return storedCurrency
              }()

              let updatedToCurrentCurrency: StoredCurrency = {
                let storedCurrency = StoredCurrency()
                storedCurrency.name = toCurrentCurrency.name
                storedCurrency.holdingAmount = toCurrentCurrency.holdingAmount + outputAmount

                return storedCurrency
              }()

              self.databaseWorker?.updateStoredCurrencies(objects: [updatedFromCurrentCurrency, updatedToCurrentCurrency]) { error in
                let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: error)
                self.presenter?.presentCompleteCurrencyConversionContract(response: response)
              }

              let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(totalAmount: requiredTotalAmount, fromCurrency: request.fromCurrency, toCurrency: response.value!.currency, toAmount: response.value!.amount, fee: fee)

              self.presenter?.presentCompleteCurrencyConversionContract(response: response)
            }


          }else{
            // Unable to receive currency from DB
            let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: ErrorType.UnsuportedCurrencyRequest())
            self.presenter?.presentCompleteCurrencyConversionContract(response: response)
          }

        case let .failure(error):
          let response = CurrencyConverter.CompleteCurrencyConversionContract.Response(error: error)
          self.presenter?.presentCompleteCurrencyConversionContract(response: response)
        }
      })
  }

  private func calculateConversionFee(visitor: TaxVisitor) -> ConversionTax {
    let conversionTax = ConversionTax(rate: 0.0)
    // Tax visitor contains all business logic on tax computation
    conversionTax.accept(visitor: visitor)

    return conversionTax
  }

  func fetchAvailableCurrencies(request: CurrencyConverter.FetchAvailableCurrencies.Request) {
    // gathering currency names from users stored currencies
    let storedCurrencies = databaseWorker.getAllStoredCurrencies()
    var currencies: [String] = []
    if let objects = storedCurrencies {
      currencies = objects.map({ storedCurrency -> String in
        storedCurrency.name
      })
    }
    let response = CurrencyConverter.FetchAvailableCurrencies.Response(currencies: currencies)
    presenter.presentAvailableCurrencies(response: response)
  }
}
